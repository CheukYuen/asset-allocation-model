# 逆向协方差矩阵估计 - 数学原理详解

## 目录
1. [问题背景](#问题背景)
2. [数学建模](#数学建模)
3. [求解方法](#求解方法)
4. [算法实现](#算法实现)
5. [结果解读](#结果解读)
6. [常见问题](#常见问题)

---

## 问题背景

### 经典问题 vs 逆向问题

| 维度 | 经典资产配置 | 逆向协方差估计 |
|------|------------|--------------|
| **已知** | 资产协方差矩阵 Σ | 组合权重 w 和目标风险 σ |
| **求解** | 最优权重 w* | 协方差矩阵 Σ* |
| **目标** | 最小化风险或最大化收益 | 匹配所有组合的风险水平 |
| **应用** | 投资决策 | 反向工程、模型校准 |

### 实际场景

假设你是基金经理，已经设计了 **105 个组合**，每个组合：
- 包含 4 种资产：现金、债券、股票、另类
- 有明确的风险等级：C1 (7%) ~ C5 (15%)
- 权重已确定，但不知道底层资产的协方差结构

**问题**: 如何根据这 105 个组合，反推出 4 种资产之间的协方差矩阵？

---

## 数学建模

### 核心公式

**组合方差** (Portfolio Variance):
```
σ²ₚ = wᵀ Σ w
```

其中：
- `w = [w₁, w₂, w₃, w₄]ᵀ` — 权重向量 (4维)
- `Σ` — 协方差矩阵 (4×4)
- `σ²ₚ` — 组合方差 (标量)

**展开形式**:
```
σ²ₚ = w₁² σ₁² + w₂² σ₂² + w₃² σ₃² + w₄² σ₄²
    + 2w₁w₂ σ₁₂ + 2w₁w₃ σ₁₃ + 2w₁w₄ σ₁₄
    + 2w₂w₃ σ₂₃ + 2w₂w₄ σ₂₄ + 2w₃w₄ σ₃₄
```

### 协方差矩阵的对称性

协方差矩阵是**对称矩阵**：
```
Σ = [σ₁²  σ₁₂  σ₁₃  σ₁₄]
    [σ₁₂  σ₂²  σ₂₃  σ₂₄]
    [σ₁₃  σ₂₃  σ₃²  σ₃₄]
    [σ₁₄  σ₂₄  σ₃₄  σ₄²]
```

**独立参数数量**:
- 对角线: 4 个 (σ₁², σ₂², σ₃², σ₄²)
- 上三角: 6 个 (σ₁₂, σ₁₃, σ₁₄, σ₂₃, σ₂₄, σ₃₄)
- **总共: 10 个独立参数**

### 参数向量表示

定义参数向量 `θ = [θ₁, θ₂, ..., θ₁₀]ᵀ`，映射为：

| 参数 | 含义 | 位置 |
|------|------|------|
| θ₁ | σ₁² | (1,1) — 现金方差 |
| θ₂ | σ₁₂ | (1,2) — 现金-债券协方差 |
| θ₃ | σ₁₃ | (1,3) — 现金-股票协方差 |
| θ₄ | σ₁₄ | (1,4) — 现金-另类协方差 |
| θ₅ | σ₂² | (2,2) — 债券方差 |
| θ₆ | σ₂₃ | (2,3) — 债券-股票协方差 |
| θ₇ | σ₂₄ | (2,4) — 债券-另类协方差 |
| θ₈ | σ₃² | (3,3) — 股票方差 |
| θ₉ | σ₃₄ | (3,4) — 股票-另类协方差 |
| θ₁₀ | σ₄² | (4,4) — 另类方差 |

### 线性化

对于第 i 个组合，权重 `wᵢ = [wᵢ₁, wᵢ₂, wᵢ₃, wᵢ₄]ᵀ`，组合方差：

```
σ²ₚ,ᵢ = wᵢᵀ Σ wᵢ = aᵢᵀ θ
```

其中设计向量 `aᵢ`：
```
aᵢ = [wᵢ₁², 2wᵢ₁wᵢ₂, 2wᵢ₁wᵢ₃, 2wᵢ₁wᵢ₄, wᵢ₂², 2wᵢ₂wᵢ₃, 2wᵢ₂wᵢ₄, wᵢ₃², 2wᵢ₃wᵢ₄, wᵢ₄²]ᵀ
```

### 优化目标

已知 105 个组合的目标风险 `σₜₐᵣ,₁, ..., σₜₐᵣ,₁₀₅`，求 θ 使得：

```
min  Σᵢ₌₁¹⁰⁵ (σ²ₚ,ᵢ - σ²ₜₐᵣ,ᵢ)²
```

即最小化**方差的误差平方和**。

### 矩阵形式

定义：
- **设计矩阵** `A` (105×10):
  ```
  A = [a₁ᵀ]
      [a₂ᵀ]
      [ ⋮ ]
      [a₁₀₅ᵀ]
  ```

- **目标向量** `b` (105×1):
  ```
  b = [σ²ₜₐᵣ,₁]
      [σ²ₜₐᵣ,₂]
      [  ⋮   ]
      [σ²ₜₐᵣ,₁₀₅]
  ```

优化问题变为：
```
min ||Aθ - b||²
```

这是标准的**线性最小二乘问题** (Linear Least Squares)。

---

## 求解方法

### 正规方程 (Normal Equation)

最小二乘的解析解：
```
θ* = (AᵀA)⁻¹ Aᵀb
```

**推导**:
1. 目标函数 `f(θ) = ||Aθ - b||² = (Aθ - b)ᵀ(Aθ - b)`
2. 对 θ 求导：`∇f(θ) = 2Aᵀ(Aθ - b)`
3. 令导数为 0：`Aᵀ(Aθ - b) = 0`
4. 整理得：`AᵀAθ = Aᵀb`
5. 解得：`θ = (AᵀA)⁻¹ Aᵀb`

### 计算复杂度

| 步骤 | 操作 | 复杂度 |
|------|------|--------|
| 构造 A | 105行 × 10列 | O(105 × 10) |
| 计算 AᵀA | 10×105 × 105×10 | O(10² × 105) ≈ 10K |
| 计算 Aᵀb | 10×105 × 105×1 | O(10 × 105) ≈ 1K |
| 求逆 (AᵀA)⁻¹ | 10×10 矩阵 | O(10³) = 1K |
| **总计** | | **O(10⁵) ≈ 0.1ms** |

### 数值稳定性

**潜在问题**:
- 如果 `AᵀA` 接近奇异 (singular)，求逆不稳定
- 权重数据共线性 → 矩阵秩不满

**解决方案**:

1. **检查矩阵秩**:
   ```python
   rank = np.linalg.matrix_rank(ATA)
   if rank < 10:
       print("警告: 矩阵秩不满")
   ```

2. **使用伪逆** (Moore-Penrose Pseudoinverse):
   ```python
   theta = np.linalg.pinv(ATA) @ ATb
   ```

3. **添加正则化** (Tikhonov Regularization):
   ```python
   lambda_ = 1e-6
   ATA_reg = ATA + lambda_ * np.eye(10)
   theta = np.linalg.inv(ATA_reg) @ ATb
   ```

### 半正定性检验

协方差矩阵必须是**半正定** (Positive Semi-Definite, PSD)：
```
对所有 x ∈ ℝ⁴, xᵀ Σ x ≥ 0
```

**等价条件**: 所有特征值 λᵢ ≥ 0

**代码检验**:
```python
eigenvalues = np.linalg.eigvals(Sigma)
is_psd = np.all(eigenvalues >= -1e-10)  # 允许数值误差
```

如果不满足，说明数据不一致或模型不合理。

---

## 算法实现

### 完整流程

```python
import numpy as np
import pandas as pd

# 1. 加载数据
df = pd.read_csv('105.csv')
weights = df[['现金%', '债券%', '股票%', '另类%']].values / 100  # 转为小数
risk_levels = df['风险等级'].map({'C1': 0.07, 'C2': 0.09, 'C3': 0.11, 'C4': 0.13, 'C5': 0.15})
target_variances = risk_levels.values ** 2  # σ² = (目标波动率)²

# 2. 构造设计矩阵 A (105×10)
n = len(weights)
A = np.zeros((n, 10))
for i in range(n):
    w = weights[i]
    A[i] = [
        w[0]**2,           # θ₁
        2*w[0]*w[1],       # θ₂
        2*w[0]*w[2],       # θ₃
        2*w[0]*w[3],       # θ₄
        w[1]**2,           # θ₅
        2*w[1]*w[2],       # θ₆
        2*w[1]*w[3],       # θ₇
        w[2]**2,           # θ₈
        2*w[2]*w[3],       # θ₉
        w[3]**2            # θ₁₀
    ]

# 3. 求解正规方程
ATA = A.T @ A
ATb = A.T @ target_variances
theta = np.linalg.solve(ATA, ATb)  # 或用 pinv

# 4. 重构协方差矩阵
Sigma = np.array([
    [theta[0], theta[1], theta[2], theta[3]],
    [theta[1], theta[4], theta[5], theta[6]],
    [theta[2], theta[5], theta[7], theta[8]],
    [theta[3], theta[6], theta[8], theta[9]]
])

# 5. 验证结果
reconstructed_vars = np.array([weights[i] @ Sigma @ weights[i] for i in range(n)])
errors = np.sqrt(reconstructed_vars) - risk_levels.values
print(f"均方根误差: {np.sqrt((errors**2).mean()):.4f}")
```

### 关键代码片段

**设计向量构造** (为什么有因子 2？):
```python
# 因为 wᵢᵀ Σ wᵢ 展开后，交叉项出现 2 次
# 例如: w₁w₂ σ₁₂ + w₂w₁ σ₂₁ = 2w₁w₂ σ₁₂ (因为 σ₁₂ = σ₂₁)
a = [w[0]**2, 2*w[0]*w[1], 2*w[0]*w[2], ...]
```

**协方差矩阵重构**:
```python
# θ 的顺序对应上三角元素（按行优先）
Sigma = np.array([
    [θ[0], θ[1], θ[2], θ[3]],   # 第1行: θ₁, θ₂, θ₃, θ₄
    [θ[1], θ[4], θ[5], θ[6]],   # 第2行: θ₂, θ₅, θ₆, θ₇ (对称)
    [θ[2], θ[5], θ[7], θ[8]],   # 第3行: θ₃, θ₆, θ₈, θ₉
    [θ[3], θ[6], θ[8], θ[9]]    # 第4行: θ₄, θ₇, θ₉, θ₁₀
])
```

---

## 结果解读

### 典型输出

```
协方差矩阵 Σ:
        现金      债券      股票      另类
现金  0.3534  -0.1561  -0.4396  -0.1224
债券 -0.1561   0.0786   0.2274   0.0766
股票 -0.4396   0.2274   0.7009   0.2625
另类 -0.1224   0.0766   0.2625   0.1218
```

### 波动率计算

对角线元素的平方根 = 波动率：
```python
volatilities = np.sqrt(np.diag(Sigma))
# [59.45%, 28.03%, 83.72%, 34.90%]
```

### 相关系数矩阵

```python
D = np.diag(1 / volatilities)  # 标准化矩阵
Corr = D @ Sigma @ D

# 结果:
#        现金     债券     股票     另类
# 现金   1.00  -0.937  -0.883  -0.590
# 债券  -0.937  1.00    0.969   0.783
# 股票  -0.883  0.969   1.00    0.898
# 另类  -0.590  0.783   0.898   1.00
```

### 经济学解释

**现金与债券高度负相关** (-0.937):
- 增加现金 → 减少债券
- 反映保守型组合的"非此即彼"逻辑

**债券与股票高度正相关** (0.969):
- 风险偏好提升时，债券和股票同时增加
- 可能债券包含信用债、可转债等风险品种

**股票与另类高度正相关** (0.898):
- 另类资产（商品、房地产、对冲基金）跟随股市
- 激进型组合同时配置股票和另类

**现金波动率异常高** (59.45%):
- 现金占比在不同组合间差异巨大 (0%~90%)
- 作为"缓冲资产"，承担了组合调节的作用
- 数学上的最优解，但不反映现金的真实风险

---

## 常见问题

### Q1: 为什么不直接用历史数据估计协方差？

| 方法 | 优点 | 缺点 |
|------|------|------|
| **历史估计** | 简单、直观 | 需要长期数据、假设平稳性 |
| **逆向估计** | 无需历史数据、反映设计意图 | 结果依赖组合配置质量 |

逆向估计适用于：
- 新产品设计阶段（无历史数据）
- 反向工程（已知组合，求资产特性）
- 模型校准（使组合风险匹配目标）

### Q2: 为什么要最小化方差误差而不是波动率误差？

**方差误差** (当前方法):
```
min Σ (σ²ₚ - σ²ₜₐᵣ)²
```

**波动率误差** (备选方案):
```
min Σ (σₚ - σₜₐᵣ)²
```

**原因**:
1. 方差是线性的 (`σ²ₚ = wᵀΣw`)，波动率是非线性的 (`σₚ = √(wᵀΣw)`)
2. 线性问题有解析解，快速稳定
3. 数值优化非线性目标更复杂，容易陷入局部最优

**结果差异**:
- 两种方法的协方差矩阵通常相近
- 方差误差法对高风险组合误差容忍度更高

### Q3: 如何处理不满足半正定的结果？

**检测**:
```python
eigenvalues = np.linalg.eigvals(Sigma)
if np.any(eigenvalues < -1e-10):
    print("协方差矩阵不是半正定的！")
```

**原因**:
- 数据不一致（105 个组合的风险等级设置不合理）
- 权重配置冲突（某些组合无法用同一个协方差矩阵解释）

**修复方法**:

1. **投影到半正定锥** (Projection onto PSD Cone):
   ```python
   eigenvalues, eigenvectors = np.linalg.eigh(Sigma)
   eigenvalues_clipped = np.maximum(eigenvalues, 0)  # 负特征值置为0
   Sigma_psd = eigenvectors @ np.diag(eigenvalues_clipped) @ eigenvectors.T
   ```

2. **添加正则化**:
   ```python
   Sigma_reg = Sigma + 0.01 * np.eye(4)  # 对角线加小量
   ```

3. **使用优化算法**:
   ```python
   from scipy.optimize import minimize

   def objective(theta):
       Sigma = build_matrix(theta)
       if not is_psd(Sigma):
           return 1e10  # 惩罚
       return np.sum((A @ theta - b)**2)

   result = minimize(objective, x0, method='SLSQP')
   ```

### Q4: 105 个组合够吗？会过拟合吗？

**参数 vs 数据**:
- 参数数量: 10 (协方差矩阵的独立元素)
- 数据数量: 105 (组合数量)
- **比例**: 105 / 10 = 10.5

**经验法则**:
- 数据/参数比 > 5 → 通常稳定
- 数据/参数比 > 10 → 不易过拟合
- 数据/参数比 < 3 → 可能欠定 (under-determined)

**本项目**:
- 比例 10.5，数据充足
- 权重分布广泛 (不同风险等级、不同配置逻辑)
- 结果稳定，误差合理 (RMSE < 2%)

### Q5: 行顺序会影响结果吗？

**不会**。数学证明：

最小二乘解：
```
θ* = (AᵀA)⁻¹ Aᵀb
```

矩阵乘法的本质是求和：
```
AᵀA = Σᵢ aᵢ aᵢᵀ   (求和与顺序无关)
Aᵀb = Σᵢ aᵢ bᵢ    (求和与顺序无关)
```

即使打乱 105 行的顺序，求和结果完全一致。

**实验验证**:
```python
# 原始顺序
theta1 = solve(weights, risk_levels)

# 随机打乱
perm = np.random.permutation(105)
theta2 = solve(weights[perm], risk_levels[perm])

# 差异
print(np.linalg.norm(theta1 - theta2))  # < 1e-14
```

---

## 扩展阅读

### 相关理论

1. **Markowitz 均值-方差模型** (1952)
   - 经典资产配置理论
   - 已知 Σ → 求 w*

2. **逆协方差估计** (Inverse Covariance Estimation)
   - 机器学习中的图模型学习
   - 本项目是简化版本（无稀疏性约束）

3. **最小二乘逆问题** (Least Squares Inverse Problems)
   - 经典数值分析问题
   - 参考书: Lawson & Hanson (1995)

### 代码优化

**当前实现**: 适合中小规模 (< 1000 组合)
```python
theta = np.linalg.solve(ATA, ATb)  # O(n³) ≈ 1ms
```

**大规模优化** (> 10,000 组合):
1. **迭代求解** (Conjugate Gradient):
   ```python
   from scipy.sparse.linalg import cg
   theta, info = cg(ATA, ATb)
   ```

2. **随机梯度下降**:
   ```python
   for epoch in range(100):
       for batch in batches:
           grad = 2 * A[batch].T @ (A[batch] @ theta - b[batch])
           theta -= learning_rate * grad
   ```

3. **并行计算** (多核 CPU):
   ```python
   from joblib import Parallel, delayed
   ATA = Parallel(n_jobs=-1)(delayed(compute_outer)(a) for a in A)
   ```

---

## 总结

### 算法优势

✅ **快速**: 解析解，毫秒级计算
✅ **稳定**: 无需初始值，结果可复现
✅ **透明**: 线性模型，易于理解和调试
✅ **通用**: 适用于任意资产数量和组合数量

### 局限性

⚠️ **不保证半正定**: 可能需要后处理
⚠️ **无约束**: 无法添加业务规则（如非负性）
⚠️ **依赖数据质量**: 组合配置不合理会导致结果异常

### 适用场景

- 新产品设计阶段的资产特性校准
- 反向工程已有投资组合
- 快速原型验证（无需优化算法的复杂性）
- 教学演示（经典数值方法）

---

**文档版本**: v1.0
**最后更新**: 2026-01-23
**技术支持**: [GitHub Issues]
