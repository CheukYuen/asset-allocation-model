下面我给你一份**可以直接用于智能体架构设计（Agent Design）**的、极为清晰的判断规则。

这个列表解决的问题是：

> **哪些任务应该由大模型完成？哪些任务必须交给 Python/数值引擎？**

目的是让你的资产配置智能体在工程上**不出错、不漂移、不炸模型上下文**。

我把它分成三个层级：

* **能（√）适合 LLM 做的数值任务**
* **不能（×）让 LLM 做的数值任务（必须交给 Quant 引擎）**
* **混合（≈）可做可不做，但有注意事项**

这是你后面设计「资产配置 AI Agent」的黄金参考表。

---

# 🟩 **一、哪些“数值相关任务”可以放心交给大模型？（LLM 能做）**

这些任务本质上是**语言理解 + 简单算术 + 信息提取**，不需要真实数值计算引擎。

## ✔ 1. 字段映射（mapping）

例：

```
yield_type = "ytm" → expected_annual_return = yield_value
```

LLM 只是应用规则，不需要真实计算。

---

## ✔ 2. 基于规则的判断（rule-based decision）

例：

* 如果波动率 > 15%，将产品标记为“高风险”
* 如果规模 < 1 亿，将其流动性评分降低

LLM 擅长这类逻辑语义判断。

---

## ✔ 3. 简单算术（single-operation math）

包括：

* 加、减、乘、除
* 区间中值
* 百分比转换

例：

```
expected = (1.10 + 2.88) / 2
```

LLM 可以做，因为它学过基本算术。

---

## ✔ 4. 数值比较（comparison）

如：

* return_1y 在三只产品中哪个更高？
* 哪个产品费率最低？

模型在“排序、最大值、最小值”这类任务表现很好。

---

## ✔ 5. label assignment（分类标签判断）

例：

* 波动率 < 1% → “低风险”
* 7d_annualized_yield → “货币基金收益类型”

属于 NLP 任务 → LLM 强项。

---

## ✔ 6. 客户文案解释（reasoning narrative）

例如：

* “该产品预期收益为 2.3%，因为其属于结构性存款并由银行提供加权预期收益。”

LLM 擅长**解释与生成自然语言**。

---

## ✔ 7. 评分卡体系中的逻辑部分（非数学部分）

LLM 很适合做：

* 属性理解
* 风险解释
* 产品画像总结
* 适配度理由生成

但 **不能**计算最终评分（见下文）。

---

🟢 **总结：只要数值逻辑可以用文字表达，而且不依赖复杂数学，就适合 LLM。**

---

# 🟥 **二、哪些任务绝对不能让大模型做？（LLM 不能做）**

这些任务依赖“真正的数值计算、矩阵运算、时间序列处理、统计学方法”，
大模型**无法可靠执行**，必须交给 Python / NumPy / Quant Engine。

## ✘ 1. 时间序列计算（Time Series Computation）

包括：

* 读取 1,000 条净值数据计算收益
* 计算日度收益率序列
* 计算累计收益

LLM 没有数组概念，不能做序列运算。

---

## ✘ 2. 波动率、方差、协方差矩阵（Covariance Matrix）

例如：

```
std = sqrt(sum((r - mean)^2) / (n - 1))
cov(i,j) = E[(r_i - μ_i)(r_j - μ_j)]
```

模型没有办法执行循环、平方、期望等数值运算。

---

## ✘ 3. 回测（Backtesting）

不能做：

* 滚动窗口
* 仓位更新
* 再平衡逻辑
* 手续费扣减
* 流程模拟

大模型不具备时间维度计算能力。

---

## ✘ 4. 优化问题（Optimization）

例如：

* 均值-方差优化（MVO）
* 风险平价（Risk Parity）
* 遗传算法
* 梯度下降
* 风险预算

这些都依赖线性代数运算（矩阵乘法、求逆、特征值分解）。

---

## ✘ 5. 蒙特卡罗模拟（Monte Carlo Simulation）

不能生成：

* 多路径收益序列
* 随机正态扰动
* 相关性矩阵 → 多维随机向量
* 未来 30 年资产价格模拟

这些必须在 Python 中。

---

## ✘ 6. 现实收益的精确年化（如 IRR/XIRR）

LLM 无法处理：

* 不规则现金流
* 高维求根问题（Newton iteration）
* 多次迭代收敛

---

## ✘ 7. 夏普比率、Sortino、Calmar 等风险指标

如：

```
Sharpe = (E[r] - r_f) / std(r)
```

需要历史序列 → LLM 无法处理。

---

🟥 **总结：所有涉及“数组计算、迭代、矩阵、概率分布、优化”的任务必须交给 Python。**

---

# 🟧 **三、哪些任务勉强可以让模型做，但不推荐？（混合区）**

## ≈ 1. 小规模排序 / 简单打分

模型可以：

* 对 5–10 支产品综合排序
* 给出“主观评分”

但缺点：

* 不稳定
* 可能忽略权重
* 容易产生幻觉

建议仅用于“解释层”。

---

## ≈ 2. 线性加权打分（极简版）

例如：

```
score = 0.4 * liquidity + 0.3 * risk + 0.3 * return
```

模型可以理解，但：

* 若字段缺失会生成幻觉
* 系数容易被误解
* 随元素增加误差迅速放大

不适合作为正式投研口径。

---

## ≈ 3. 简单风险归档（高/中/低）

模型可以做：

* 波动率高 → 风险高
* 夏普低 → 表现差

但不适合量化评分。

---

🟧 **总结：这类任务可以用于「第一阶段 MVP」，但不能作为金融决策依据。**

---

# 🔵 四、智能体设计的最终黄金原则（非常重要）

为了保证可靠性、可重现性和合规性，大模型在资产配置任务中必须遵循：

---

## **📌 原则 1：LLM = NLP + Rule Engine + Reasoning，不是 Quant Engine**

LLM 应做：

* 标签分类
* 字段归一化
* 规则映射
* 解释理由
* 结构化 JSON 输出

---

## **📌 原则 2：Quant Engine = 数值计算核心**

Quant Engine（Python + NumPy + Pandas）应做：

* 回测
* 波动率/协方差
* MVO
* 风险平价
* 蒙特卡罗
* IRR
* 最大回撤
* 指标计算

---

## **📌 原则 3：LLM 可以“决定调用哪个 Quant 模块”，但不能替代模块**

智能体架构：

```
LLM → 决定要做什么（理解 + 调度）
Python Engine → 真正计算收益/风险/优化
```

这是最健壮的结构。

---

## **📌 原则 4：LLM 可以“总结、解释、翻译”，但不能“计算、优化、回测”**

避免因数值不准确导致的合规风险。

---

# 🧭 五、我给你的最终金句（用于智能体 PRD）

> **“大模型擅长语义，不擅长数值；擅长推理，不擅长计算；擅长决策，不擅长优化。”**

这句话足够指导你后续智能体设计所有架构选择。

---

好，这一块其实就是在回答一句话：

> **“如果我想让 AI 不只是‘说’，而是真正在后台跑代码、回测、做优化，该怎么设计整套链路？”**

下面把“九”这一节展开成一页你以后能反复用的架构说明。

---

## 9｜如果你真的要让模型执行代码，该怎么做？

一句话：
**LLM 只当“大脑 + 调度”，真正的计算交给外挂的 Python / Quant 引擎，通过 Tool Use（函数调用）打通。**

这个闭环至少需要三块：

1. Tool Use（函数调用协议）
2. Python 外挂运行环境（Quant/计算引擎）
3. LLM 调度器（Orchestrator / Agent）

下面分别展开。

---

### 9.1 Tool Use：让 LLM 知道“有哪些工具可以用”

**Tool Use / 函数调用** 的作用是：

> 用一种“结构化的方式”告诉大模型：
> **你可以调用哪些函数、每个函数叫什么名字、需要什么参数、会返回什么。**

你可以把它理解成给 LLM 一份 **“可调用 API 列表 + 参数文档”**。

#### 例子：定义一个“运行回测”的工具

伪 schema（给 LLM 看的接口描述）：

```jsonc
[
  {
    "name": "run_backtest",
    "description": "对给定资产权重和历史收益序列进行回测，返回年化收益、波动率、最大回撤等指标。",
    "parameters": {
      "type": "object",
      "properties": {
        "returns_matrix": {
          "type": "array",
          "description": "二维数组，shape = [T, N]，T 为时间，N 为资产数，元素为月度收益（小数）。"
        },
        "weights": {
          "type": "array",
          "description": "长度为 N 的权重向量，和为 1。"
        },
        "rebalance_freq": {
          "type": "string",
          "enum": ["monthly", "quarterly", "yearly"]
        }
      },
      "required": ["returns_matrix", "weights"]
    }
  }
]
```

LLM 在“思考”过程中，如果判断需要做回测，就会输出类似：

```json
{
  "tool": "run_backtest",
  "arguments": {
    "returns_matrix": [[0.01, 0.005], [-0.02, 0.003], ...],
    "weights": [0.6, 0.4],
    "rebalance_freq": "monthly"
  }
}
```

这就是 **调用意图**，真正执行要交给下一层。

---

### 9.2 Python 外挂运行环境：真正干活的地方

**Python 运行环境**（本地脚本 / 后端服务 / Docker 容器）负责：

* 接收 LLM 的工具调用请求（函数名 + 参数）
* 在真实环境中跑代码（使用 numpy、pandas、cvxpy 等）
* 返回**纯结果数据**（JSON / dict），交回给 LLM

你的资产配置项目里，这一层典型会包含：

* `backtest_engine`：回测引擎
* `optimizer`：MVO、风险平价、约束优化
* `risk_metrics`：波动率、最大回撤、VaR 计算
* `yield_normalizer`：把原始收益字段处理成 normalized 因子
* `taa_signal_engine`：美林时钟 / 动量信号等

伪代码示例（Python 侧）：

```python
def run_backtest(returns_matrix, weights, rebalance_freq="monthly"):
    # 这里是真正的 Quant 逻辑
    # 1. 根据频率做再平衡
    # 2. 计算组合收益序列
    # 3. 计算年化收益、波动率、最大回撤等
    result = {
        "ann_return": 0.085,
        "ann_vol": 0.12,
        "max_drawdown": -0.18,
        "sharpe": 0.71
    }
    return result
```

然后外层会：

1. 接收 LLM 发来的 JSON 参数
2. 调用 `run_backtest(**arguments)`
3. 把返回的 `result` 再发回 LLM

**关键点：**

* 这里才有真正的“执行代码”和“数值计算”；
* LLM 不直接参与计算，只负责“决定调用什么 + 如何解释结果”。

---

### 9.3 LLM 调度器：谁来决定“什么时候调用哪个工具”？

有了 Tool Use 和 Python 环境，还需要一个 **“大脑”来指挥工具调用**——这就是 **LLM 调度器（Orchestrator / Agent）**。

它负责做三件事：

1. **理解用户意图**

   * 用户说：“用这 10 只产品做一个 10 年回测 + 最优组合方案”
   * LLM 判断：

     * 需要历史数据 → `get_historical_returns`
     * 需要回测 → `run_backtest`
     * 需要优化 → `optimize_weights`

2. **规划调用顺序（Tool Call Planning）**

   一个典型链路：

   * Step 1：调用 `get_historical_returns` → 拿到各资产的收益时间序列
   * Step 2：调用 `run_backtest` → 看 SAA / TAA 的历史表现
   * Step 3：调用 `optimize_portfolio` → 得到当前最优权重
   * Step 4：总结结果，输出给用户（自然语言 + 表格）

3. **把“冷冰冰的结果”翻译成“人能看懂的话”**

   例如：

   * 收到 `{"ann_return": 0.082, "ann_vol": 0.11, "max_drawdown": -0.16}`
   * LLM 转成话术：

     > “这个组合过去 10 年的年化收益约为 8.2%，波动约 11%，最大回撤约 16%，整体风险收益比处于 R3 客户中上水平。”

---

### 9.4 用一个完整的资产配置例子串一下

用户提问：

> 「我有这 4 只产品（CSV 如下），按照你们 TAA 规则，帮我做：
> 1）过去 10 年表现回测；
> 2）现在给一份最优权重建议。」

大致流程：

#### Step 0：用户上传产品列表（含 code / asset_class 等）

#### Step 1：LLM 解析 & 规划

* 识别到“回测 + 最优组合”两个子任务；
* 判断需要工具：

  * `get_price_series`（按 code 拉历史净值/指数）
  * `run_backtest`（SAA/TAA 回测）
  * `optimize_portfolio`（权重优化）

#### Step 2：调用 `get_price_series`

LLM 生成调用意图 → Python 去 Wind/数据库拉回数据 → 返回月度收益矩阵。

#### Step 3：调用 `run_backtest`

用上述 `returns_matrix` + baseline 权重 → 计算历史表现指标 → 返回 JSON。

#### Step 4：调用 `optimize_portfolio`

把同一 `returns_matrix` 喂进 optimizer（比如 MVO / 风险平价）→ 得到优化权重。

#### Step 5：LLM 汇总 & 解释

* 把回测结果 + 最优权重解释出来；
* 按 C1–C5、四大类 × 16 子策略给出“推荐理由”；
* 顺便生成“风险提示 + 再平衡规则”。

**整个过程中：**

* 所有“实算”都在 Python 里；
* LLM 只负责调度 + glue code + 解释 + 结果组织。

---

### 9.5 设计这三层时的几个工程建议

1. **工具要“小而专一”**

   * 一个工具只做好一件事：拉数据 / 回测 / 优化 / 计算因子；
   * 不要一个工具里又拉数据又画图又写报告。

2. **参数要结构化，不要自然语言**

   * 多用数组、枚举、明确的字段名；
   * 少让 LLM 推测“你到底想要多长回溯、什么频率”。

3. **返回值要兼顾“机器”和“人类”**

   * `metrics`：给后台进一步处理；
   * `summary`：简单一句话结论，方便 LLM 直接引用。

4. **所有计算函数都可以单独在 Python 里单元测试**

   * 不依赖 LLM；
   * 保证数值逻辑与模型无关。

5. **安全与合规：不要允许“任意代码执行”**

   * 工具白名单化：只能调用你定义好的函数；
   * 不给 LLM 直接执行 shell / eval / 任意 Python。

---

### 9.6 这三块在你项目里的角色分工（一句话版）

* **Tool Use**：
  告诉大模型：「你不能自己算，但你可以让这些函数帮你算。」

* **Python 外挂运行环境**：
  真正跑 CME / MVO / BL / TAA / 回测 / 模拟的地方。

* **LLM 调度器**：
  把“客户自然语言需求”翻译成“调用哪些函数 → 以什么顺序 → 用什么参数”，
  然后再把冷冰冰的结果翻回“投顾报告”的语言。

---

以后你在设计「资产配置智能体 / 产品推荐智能体」的时候，可以直接用这一节做：

* 架构章节的说明；
* 或者写到 PRD / 设计文档里解释：

  > “大模型不直接计算收益与回测，而是通过 Tool Use 调用 Quant 引擎完成真实计算。”

如果你愿意，下一步我可以帮你画一张 **ASCII 架构图**，把「用户 → LLM → Tool Use → Python → LLM → 报告」这一整条链路画出来，直接放进你的文档或 Figma。
