# TAA Learning Project 核心功能总结

## 项目概述

本项目是一个**战术资产配置（TAA）学习项目**，通过实现完整的 TAA 计算链路，学习 Python、NumPy 和 pandas 的数据处理与向量化运算。项目采用模块化设计，实现了从数据生成、信号计算、回测分析到风险模拟的完整工作流。

---

## 核心功能模块

### 1. TAA 信号引擎（TAA Signal Engine）

**文件位置**: `core/taa_signal_engine.py`

**核心功能**:
- **基于宏观象限的权重动态调整**
  - 支持 4 个宏观象限：复苏（Recovery）、过热（Overheat）、滞涨（Stagflation）、衰退（Recession）
  - 16 个子策略映射到 4 个资产大类：现金、债券、权益、另类
  - 根据宏观象限自动调整资产大类权重，并按 SAA 基准比例分配到子策略

**关键算法**:

1. **资产大类倾斜量获取**：根据当前宏观象限 $q_t$，获取资产大类 $AC$ 的倾斜量
   $$
   \Delta w_{asset,t}(AC) = \text{lookup}(q_t, AC)
   $$

2. **策略级倾斜量分配**：将资产大类倾斜量按 SAA 权重比例分配到各子策略
   $$
   \Delta w_{strategy,i,t}^{(0)} = \Delta w_{asset,t}(AC_i) \cdot \frac{w_{SAA,i}}{\sum_{j \in AC_i} w_{SAA,j}}
   $$
   其中 $AC_i$ 表示策略 $i$ 所属的资产大类。

3. **临时权重计算**：将倾斜量叠加到 SAA 基准权重
   $$
   w_{temp,i,t} = w_{SAA,i} + \Delta w_{strategy,i,t}^{(0)}
   $$

4. **权重归一化**：确保权重和为 1 且无负值
   $$
   w_{final,i,t} = \frac{\max(w_{temp,i,t}, 0)}{\sum_{j=1}^{16} \max(w_{temp,j,t}, 0)}
   $$

**输出**: 月度权重矩阵 `(T × 16)`，每行代表一个月的最终配置权重

---

### 2. 回测引擎（Backtest Engine）

**文件位置**: `core/backtest_engine.py`

**核心功能**:
- **完整的绩效分析指标体系**

#### 1. 组合月度收益
$$
r_{p,t} = \sum_{i=1}^{16} w_{i,t} \cdot r_{i,t}
$$
其中 $w_{i,t}$ 为策略 $i$ 在时刻 $t$ 的权重，$r_{i,t}$ 为策略 $i$ 在时刻 $t$ 的收益率。

#### 2. 累计收益曲线（财富指数）
$$
C_0 = 1.0, \quad C_t = \prod_{k=1}^{t} (1 + r_{p,k})
$$

#### 3. 年化收益率（几何复利）
$$
R_{annual} = (1 + R_{total})^{\frac{12}{T}} - 1
$$
其中 $R_{total} = C_T - 1$ 为总收益率，$T$ 为月数。

#### 4. 年化波动率
$$
\sigma_{annual} = \sigma_{monthly} \cdot \sqrt{12}
$$
其中 $\sigma_{monthly}$ 为月度收益率的标准差。

#### 5. 夏普比率
$$
\text{Sharpe} = \frac{R_{annual} - r_f}{\sigma_{annual}}
$$
其中 $r_f$ 为无风险利率（默认 0）。

#### 6. 最大回撤（MDD）
$$
\text{MDD} = \min_t \left( \frac{C_t}{\max_{k \leq t} C_k} - 1 \right)
$$

#### 7. 卡玛比率
$$
\text{Calmar} = \frac{R_{annual}}{|\text{MDD}|}
$$

#### 8. 胜率
$$
\text{Win Rate} = \frac{\#\{t: r_{p,t} > 0\}}{T}
$$

**应用场景**:
- 评估 TAA 策略相对于 SAA 基准的表现
- 对比不同配置方案的风险收益特征
- 生成标准化的绩效报告

**输出**: 包含所有绩效指标的字典，可直接用于报告生成

---

### 3. 蒙特卡罗模拟引擎（Monte Carlo Simulation）

**文件位置**: `core/mc_simulation.py`

**核心功能**:
- **未来财富路径模拟**

#### 财富演化公式
$$
W_0 = 1.0, \quad W_{t+1} = W_t \cdot (1 + r_{t,k})
$$
其中 $r_{t,k}$ 为路径 $k$ 在时刻 $t$ 的模拟月度收益。

#### 模拟方法

**1. 正态分布法（参数化）**
$$
r_{t,k} \sim \mathcal{N}(\mu, \sigma^2)
$$
其中 $\mu = \text{mean}(r_{historical})$，$\sigma = \text{std}(r_{historical})$。

**2. 自助法（非参数化）**
$$
r_{t,k} = r_{historical}[i_{t,k}], \quad i_{t,k} \sim \text{Uniform}(0, T_{hist}-1)
$$
从历史收益序列中有放回随机抽样。

- 可自定义模拟期限（默认 30 年）和路径数量（默认 1000 条）

**分析维度**:

#### 终端财富分布分析

- **分位数统计**：计算终端财富 $W_T$ 的分位数
  $$
  Q_q = \text{Quantile}(W_T, q), \quad q \in \{0.05, 0.25, 0.50, 0.75, 0.95\}
  $$

- **成功概率**：达到目标财富的概率
  $$
  P(W_T \geq W_{goal}) = \frac{\#\{k: W_{T,k} \geq W_{goal}\}}{N_{paths}}
  $$

- **亏损概率**：终端财富低于初始投资的概率
  $$
  P(W_T < 1.0) = \frac{\#\{k: W_{T,k} < 1.0\}}{N_{paths}}
  $$

#### 时间序列分位数路径

- 展示不同置信区间的财富演化路径
  $$
  Q_{q,t} = \text{Quantile}(\{W_{t,k}\}_{k=1}^{N_{paths}}, q)
  $$
- 用于可视化"扇形图"展示不确定性范围

**应用场景**:
- 长期财富规划
- 退休金目标达成概率评估
- 风险情景分析

---

### 4. 模拟数据生成器（Mock Data Generator）

**文件位置**: `core/mock_data.py`

**核心功能**:
- **生成完整的合成数据集**

#### 1. SAA 基准权重生成
$$
w_{SAA,i} = \frac{u_i}{\sum_{j=1}^{16} u_j}, \quad u_i \sim \text{Uniform}(0, 1)
$$
其中 $u_i$ 为随机数，最终权重归一化后和为 1。

#### 2. 月度收益率生成
$$
r_{i,t} = \mu_i + \sigma_i \cdot \epsilon_{i,t}, \quad \epsilon_{i,t} \sim \mathcal{N}(0, 1)
$$
其中 $\mu_i$ 和 $\sigma_i$ 分别为策略 $i$ 的预期月度收益和波动率。

#### 3. 宏观象限生成
- 按固定周期循环：Recovery → Overheat → Stagflation → Recession
- 每个象限持续 $T/4$ 个月

**数据特征**:
- 可复现性：使用固定随机种子（seed=42）
- 真实性：不同策略具有不同的预期收益和波动率
- 灵活性：可自定义时间长度和策略数量

**应用场景**:
- 开发测试
- 算法验证
- 教学演示

---

### 5. 可执行脚本（Scripts）

**文件位置**: `scripts/`

#### 5.1 数据生成脚本
- `run_mock_data.py`: 生成模拟数据并保存为 CSV 文件

#### 5.2 回测脚本
- `run_backtest.py`: 加载数据 → 计算 TAA 权重 → 运行回测 → 生成报告

---

## 技术架构

### 模块依赖关系

```
mock_data.py (底层，无依赖)
    ↓
taa_signal_engine.py (中层，依赖 utils)
    ↓
backtest_engine.py (中层，依赖 taa_signal_engine)
    ↓
mc_simulation.py (中层，依赖 backtest_engine)
    ↓
scripts/*.py (顶层，可调用所有模块)
```

### 技术栈

- **Python**: 3.9+（兼容 3.11）
- **核心库**: NumPy、pandas
- **设计原则**: 
  - 纯 Python 实现，无外部科学计算库依赖（如 scipy）
  - 模块化设计，避免循环依赖
  - 类型提示和完整文档字符串
  - 可独立运行的演示代码

---

## 数据流

### 完整工作流

```
1. 数据准备
   └─> mock_data.py 生成 SAA 权重、收益率、宏观象限

2. TAA 权重计算
   └─> taa_signal_engine.py 根据宏观象限调整权重

3. 绩效分析
   └─> backtest_engine.py 计算组合收益和各项指标

4. 风险模拟（可选）
   └─> mc_simulation.py 模拟未来财富路径
```

### 数据格式

- **SAA 权重**: `np.ndarray` 形状 `(16,)`，和为 1
- **收益率矩阵**: `pd.DataFrame` 形状 `(T, 16)`，列为策略名
- **宏观象限**: `pd.Series` 形状 `(T,)`，值为象限名称
- **最终权重**: `pd.DataFrame` 形状 `(T, 16)`，每行和为 1

---

## 所需要使用和支撑的量化数据

### 1. 输入数据需求

#### 1.1 SAA 基准权重（Strategic Asset Allocation）

**数据描述**: 客户或组合的战略资产配置基准权重

**数据格式**:
- **类型**: `np.ndarray` 或 `pd.Series`
- **维度**: `(16,)` - 对应 16 个子策略
- **约束条件**:
  $$
  \sum_{i=1}^{16} w_{SAA,i} = 1, \quad w_{SAA,i} \geq 0 \quad \forall i
  $$

**数据来源**:
- 客户风险偏好评估结果
- 投资政策声明（IPS）
- 历史配置方案
- 默认配置模板

**示例数据**:
```python
w_saa = np.array([
    0.05,  # Cash
    0.10,  # DepositFixedIncome
    0.15,  # PureBond
    0.08,  # NonStandardFixedIncome
    0.12,  # FixedIncomePlus
    0.05,  # OverseasBond
    0.10,  # BalancedFund
    0.15,  # EquityA
    0.08,  # EquityOverseas
    0.05,  # OverseasBalanced
    0.02,  # Commodity
    0.02,  # HedgeFund
    0.01,  # RealEstate
    0.01,  # PrivateEquity
    0.01,  # OverseasAlternative
    0.00   # StructuredProduct
])
```

---

#### 1.2 历史收益率数据（Historical Returns）

**数据描述**: 各子策略的历史月度收益率序列

**数据格式**:
- **类型**: `pd.DataFrame`
- **维度**: `(T, 16)` - T 个月 × 16 个策略
- **索引**: 时间索引（DatetimeIndex，月度频率）
- **列名**: 16 个子策略名称（固定顺序）
- **数值**: 月度收益率（小数形式，如 0.01 表示 1%）

**数据要求**:
- **时间跨度**: 建议至少 60 个月（5 年）历史数据，推荐 120 个月（10 年）以上
- **数据频率**: 月度数据（Monthly）
- **缺失值处理**: 不允许缺失值，需提前处理（前向填充、插值或删除）
- **异常值处理**: 建议进行异常值检测和清洗

**收益率计算公式**:
$$
r_{i,t} = \frac{P_{i,t} - P_{i,t-1}}{P_{i,t-1}}
$$
其中 $P_{i,t}$ 为策略 $i$ 在时刻 $t$ 的净值或价格。

**数据来源**:
- 基金净值数据（Wind、Choice、Bloomberg）
- 指数收益率数据
- 产品业绩基准数据
- 合成策略收益率（基于持仓数据计算）

**CSV 格式示例**:
```csv
date,Cash,DepositFixedIncome,PureBond,...
2015-01-01,0.0020,0.0030,0.0035,...
2015-02-01,0.0021,0.0028,0.0032,...
...
```

---

#### 1.3 宏观象限时间序列（Macro Quadrants）

**数据描述**: 每个时间点对应的宏观经济象限标识

**数据格式**:
- **类型**: `pd.Series`
- **维度**: `(T,)` - T 个月
- **索引**: 时间索引（与收益率数据对齐）
- **数值**: 象限名称字符串，必须为以下之一：
  - `"Recovery"` - 复苏期
  - `"Overheat"` - 过热期
  - `"Stagflation"` - 滞涨期
  - `"Recession"` - 衰退期

**数据要求**:
- **时间对齐**: 必须与收益率数据的时间索引完全一致
- **无缺失值**: 每个时间点必须有明确的象限标识
- **连续性**: 建议象限变化平滑，避免频繁切换

**象限判断标准**（建议）:

| 象限 | 经济增长 | 通胀水平 | 典型特征 |
|------|---------|---------|---------|
| Recovery | 上升 | 低 | GDP↑, CPI↓, 货币政策宽松 |
| Overheat | 上升 | 高 | GDP↑, CPI↑, 货币政策收紧 |
| Stagflation | 下降 | 高 | GDP↓, CPI↑, 经济停滞 |
| Recession | 下降 | 低 | GDP↓, CPI↓, 货币政策宽松 |

**数据来源**:
- 宏观经济指标（GDP 增长率、CPI、PMI 等）
- 美林时钟模型判断
- 第三方宏观研究机构报告
- 量化模型自动识别

**CSV 格式示例**:
```csv
date,quadrant
2015-01-01,Recovery
2015-02-01,Recovery
2015-03-01,Overheat
...
```

---

### 2. 数据质量要求

#### 2.1 完整性要求

- **时间连续性**: 收益率数据应连续，无时间跳跃
- **策略完整性**: 16 个子策略数据应齐全，缺失策略需用 0 或基准替代
- **数据对齐**: 三个数据源（SAA、收益率、象限）的时间索引必须对齐

#### 2.2 准确性要求

- **收益率精度**: 建议保留 4-6 位小数
- **权重归一化**: SAA 权重和必须等于 1.0（允许浮点误差 ±1e-6）
- **象限有效性**: 象限值必须严格匹配预定义集合

#### 2.3 一致性要求

- **策略名称**: 所有数据源中的策略名称必须一致（大小写敏感）
- **时间格式**: 统一使用 `YYYY-MM-DD` 格式
- **数据频率**: 统一为月度数据

---

### 3. 数据预处理流程

#### 3.1 数据清洗

1. **缺失值处理**
   - 前向填充（Forward Fill）
   - 线性插值
   - 删除缺失行（如果缺失率 < 5%）

2. **异常值检测**
   - 3σ 原则：剔除超出均值 ±3 倍标准差的数据
   - 分位数方法：剔除超出 1% 和 99% 分位数的数据

3. **数据验证**
   - 检查权重和是否为 1
   - 检查收益率是否在合理范围（如 [-50%, +50%]）
   - 检查象限值是否有效

#### 3.2 数据转换

1. **收益率转换**
   - 如果输入为价格/净值，转换为收益率
   - 如果输入为百分比形式（如 1%），转换为小数（0.01）

2. **时间索引标准化**
   - 统一转换为 `pd.DatetimeIndex`
   - 确保频率为月度（'MS' - Month Start）

3. **策略名称标准化**
   - 确保列名与固定策略列表完全匹配

---

### 4. 数据存储格式

#### 4.1 CSV 文件格式（推荐用于数据交换）

**文件结构**:
```
data/
├── saa_weights.csv          # SAA 权重（单行，16 列）
├── historical_returns.csv   # 历史收益率（T 行 × 16 列）
└── macro_quadrants.csv      # 宏观象限（T 行 × 1 列）
```

**CSV 文件规范**:
- 编码：UTF-8
- 分隔符：逗号（`,`）
- 首行：列名（header）
- 日期格式：`YYYY-MM-DD`

#### 4.2 Python 对象格式（推荐用于程序内部）

- **SAA 权重**: `np.ndarray` 或 `pd.Series`
- **收益率**: `pd.DataFrame` with `DatetimeIndex`
- **象限**: `pd.Series` with `DatetimeIndex`

---

### 5. 数据来源建议

#### 5.1 公开数据源

- **Wind 万得**: 基金净值、指数数据
- **Choice 同花顺**: 产品业绩数据
- **Bloomberg**: 全球市场数据
- **中证指数**: 指数收益率数据
- **央行/统计局**: 宏观经济指标

#### 5.2 内部数据源

- **产品管理系统**: 产品净值数据
- **投资研究系统**: 策略基准数据
- **客户管理系统**: 客户配置偏好数据
- **风险管理系统**: 历史配置记录

#### 5.3 数据更新频率

- **收益率数据**: 每月更新（T+1 日）
- **宏观象限**: 每月更新（根据最新宏观指标）
- **SAA 权重**: 按需更新（客户需求变化时）

---

### 6. 数据量估算

#### 6.1 最小数据需求

- **历史收益率**: 至少 60 个月（5 年）
- **宏观象限**: 与收益率数据同期
- **SAA 权重**: 单次输入（16 个数值）

#### 6.2 推荐数据量

- **历史收益率**: 120 个月（10 年）以上
- **宏观象限**: 与收益率数据同期
- **数据点总数**: 约 1,920 个数据点（120 月 × 16 策略）

#### 6.3 存储空间估算

- **CSV 格式**: 约 100-500 KB（取决于时间跨度）
- **内存占用**: 约 1-5 MB（pandas DataFrame）

---

### 7. 数据验证检查清单

在数据输入前，建议进行以下检查：

- [ ] SAA 权重和为 1.0（允许误差 ±1e-6）
- [ ] 收益率数据无缺失值
- [ ] 收益率数据无异常值（超出合理范围）
- [ ] 宏观象限值全部有效（4 个预定义值之一）
- [ ] 时间索引对齐（三个数据源时间一致）
- [ ] 策略名称匹配（16 个策略名称完全一致）
- [ ] 数据频率统一（全部为月度数据）
- [ ] 时间跨度足够（≥ 60 个月）

---

## 核心价值

### 1. 学习价值
- **Python 数据处理**: 掌握 NumPy 向量化运算和 pandas DataFrame 操作
- **量化金融**: 理解 TAA 策略的核心逻辑和实现方法
- **工程化实践**: 学习模块化设计、接口规范和代码组织

### 2. 业务价值
- **策略验证**: 可快速验证不同 TAA 配置方案的效果
- **风险分析**: 通过蒙特卡罗模拟评估长期投资目标达成概率
- **绩效评估**: 提供标准化的回测指标，支持策略对比和优化

### 3. 扩展性
- **易于集成**: 模块化设计便于集成到更大的系统中
- **数据接口**: 支持从 CSV 文件加载真实数据
- **功能扩展**: 可轻松添加新的分析指标或模拟方法

---

## 使用示例

### 快速开始

```python
# 1. 生成模拟数据
from core.mock_data import create_mock_dataset
w_saa, returns_df, quadrants = create_mock_dataset(n_months=120)

# 2. 计算 TAA 权重
from core.taa_signal_engine import compute_final_weights_over_time, get_strategy_metadata, DELTA_ASSET
metadata = get_strategy_metadata()
weights_df = compute_final_weights_over_time(w_saa, quadrants, metadata, DELTA_ASSET)

# 3. 运行回测
from core.backtest_engine import aggregate_backtest_metrics
metrics = aggregate_backtest_metrics(returns_df, weights_df)
print(f"年化收益率: {metrics['annualized_return']:.2%}")
print(f"夏普比率: {metrics['sharpe_ratio']:.2f}")

# 4. 蒙特卡罗模拟（可选）
from core.backtest_engine import compute_portfolio_returns
from core.mc_simulation import aggregate_mc_results
portfolio_returns = compute_portfolio_returns(returns_df, weights_df)
mc_results = aggregate_mc_results(portfolio_returns, n_years=30, goal_wealth=3.0)
print(f"达到3倍目标的概率: {mc_results['terminal_summary']['prob_above_goal']:.1%}")
```

---

## 项目文件结构

```
taa_learning_project/
├── AGENTS.md                    # 项目全局规范文档
├── core/                        # 核心模块
│   ├── mock_data.py            # 模拟数据生成
│   ├── taa_signal_engine.py    # TAA 信号引擎
│   ├── backtest_engine.py      # 回测引擎
│   └── mc_simulation.py        # 蒙特卡罗模拟
└── scripts/                     # 可执行脚本
    ├── run_mock_data.py        # 数据生成脚本
    └── run_backtest.py         # 回测脚本
```

---

## 总结

本项目实现了一个**完整的 TAA 策略计算与评估系统**，从数据生成、信号计算、绩效回测到风险模拟，形成了闭环的工作流。代码遵循工程化规范，模块化设计清晰，既适合学习 Python 量化开发，也可作为实际业务的原型系统。

**核心优势**:
- ✅ 功能完整：覆盖 TAA 策略的全流程
- ✅ 代码规范：类型提示、文档完善、可独立运行
- ✅ 易于扩展：模块化设计，便于添加新功能
- ✅ 实用性强：可直接用于策略验证和风险分析

---

*文档生成时间: 2025年*
*项目版本: v1.0*
